# Avito Shop API

Avito Shop API — это внутренний API для сотрудников, который позволяет покупать фирменный мерч за виртуальные монеты и переводить монеты между собой. Проект разработан с использованием языка Go, веб-фреймворка Gin, ORM Gorm, PostgreSQL в качестве базы данных и JWT для аутентификации. Документация API генерируется с помощью [swaggo/swag](https://github.com/swaggo/swag).

---

## Функциональные возможности

- **Аутентификация и регистрация пользователей**  
  Если пользователь не существует, система автоматически регистрирует его, а затем выдает JWT-токен. В случае существования пользователя производится проверка пароля и возврат токена.

- **Получение информации о пользователе**  
  API возвращает актуальный баланс монет, список купленного мерча и историю транзакций.

- **Покупка мерча**  
  Пользователь может приобрести мерч за монеты. При покупке происходит списание средств, добавление элемента в инвентарь и регистрация транзакции.

- **Перевод монет**  
  Пользователь может отправить монеты другому сотруднику, что также сопровождается созданием записи транзакции.

---

## Технологический стек

- **Язык программирования:** Go (Golang)
- **Веб-фреймворк:** Gin
- **ORM:** Gorm
- **База данных:** PostgreSQL
- **Аутентификация:** JWT (golang-jwt/jwt) и bcrypt для хэширования паролей
- **Документация API:** Swagger (swaggo/swag)
- **Контейнеризация:** Docker, Docker Compose

---

## Установка и запуск

### Предварительные требования

- [Docker](https://www.docker.com/)
- [Docker Compose](https://docs.docker.com/compose/)

### Переменные окружения

Проект использует следующие переменные окружения. Значения по умолчанию заданы в коде, но их можно переопределить:

- `APP_PORT` — порт, на котором запускается приложение (по умолчанию: `8080`)
- `DB_HOST` — хост базы данных (по умолчанию: `localhost`)
- `DB_PORT` — порт базы данных (по умолчанию: `5432`)
- `DB_USER` — пользователь базы данных (по умолчанию: `postgres`)
- `DB_PASSWORD` — пароль для базы данных (по умолчанию: `postgres`)
- `DB_NAME` — имя базы данных (по умолчанию: `avito_shop`)
- `JWT_SECRET` — секретный ключ для генерации JWT (по умолчанию: `avitomiraines`)

Для удобства можно создать файл `.env` в корневой директории проекта со следующим содержимым:

```env
APP_PORT=8080
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=postgres
DB_NAME=avito_shop
JWT_SECRET=avitomiraines
```
## Запуск с помощью Docker Compose
Для сборки и запуска проекта выполните команду:
```
docker-compose up --build
```

Эта команда:

- **Собирает контейнеры** с вашим приложением и базой данных.
- **Выполняет миграцию** базы данных.
- **Загружает начальные данные** (например, товары для мерча).
- **Запускает HTTP-сервер** на указанном порту.

После успешного запуска API будет доступен по адресу:
```
http://localhost:8080
```
Документация Swagger доступна по адресу:
```
http://localhost:8080/swagger/index.html
```

---

## Тестирование

Проект охватывается комплексным набором тестов, что позволяет гарантировать его стабильную работу и выявлять ошибки на ранних стадиях разработки. В репозитории присутствуют:

- **Интеграционные тесты:**  
    Эти тесты проверяют корректность работы всех слоев приложения — от контроллеров до доступа к базе данных. Для интеграционного тестирования используется in-memory база данных (SQLite), что обеспечивает быстрое выполнение тестов и изоляцию от внешних зависимостей. Примеры интеграционных тестов включают проверки:
    
    - Аутентификации (регистрация и логин) с валидацией JWT-токенов.
    - Покупки мерча, включая сценарии с новым и уже существующим товаром.
    - Переводов монет между пользователями, включая проверку на недостаток средств и некорректные сценарии.
    - Получения информации о пользователе (инвентарь и история транзакций).
- **Модульные тесты (Unit-тесты):**  
    Модульные тесты используют мок-объекты для изоляции отдельных компонентов системы, что позволяет протестировать бизнес-логику без обращения к реальной базе данных. Они охватывают:
    
    - Логику регистрации и входа пользователей.
    - Механизмы покупки мерча и списания монет.
    - Трансфер монет между пользователями.
    - Получение информации о пользователе.
- **Нагрузочное тестирование (Load Testing)**  
Для оценки производительности и устойчивости приложения под высокой нагрузкой я использовал инструмент [k6](https://k6.io/). Пример сценария и конфигурацию скрипта для нагрузочного теста можно найти в файле проекта `k6-script.js`
Результаты нагрузочного тестирования:

![image](https://github.com/user-attachments/assets/47803b6d-2f3c-4c3f-83f1-7993825a3ee7)

Тесты можно запустить стандартной командой:
```
go test ./...
```

---

## Линтер

Для поддержания высокого качества кода в проекте используется собственная конфигурация линтера. Этот набор инструментов помогает соблюдать кодстайл, избегать распространенных ошибок и оптимизировать производительность. Конфигурацию можно найти в файле проекта `.golangci-lint.yaml`

Эта конфигурация позволяет:

- Проверять ошибки и возможные уязвимости кода (`govet`, `errcheck`, `gosec`).
- Анализировать сложность и повторяющийся код (`gocyclo`, `goconst`, `unparam`).
- Следить за оформлением и стилем кода (`gofmt`, `revive`, `whitespace`).
  
---

## Проблемы, с которыми я столкнулся, и их решения

### 1. **Атомарность операций при работе с базой данных**

**Проблема:**  
При покупке мерча или переводе монет необходимо обеспечить атомарное выполнение нескольких операций: списание или зачисление монет, обновление инвентаря, регистрация транзакций. Отказ одной операции не должен приводить к неконсистентному состоянию данных.

**Решение:**  
Использование транзакций Gorm (`db.Transaction()`) позволило сгруппировать взаимосвязанные операции в единый атомарный блок. В случае возникновения ошибки транзакция откатывается, что гарантирует целостность данных.

---

### 2. **Аутентификация и безопасность**

**Проблема:**  
Необходимо обеспечить безопасную регистрацию и логин, а также защитить приватные маршруты, чтобы доступ к ним имели только авторизованные пользователи.

**Решение:**

- **JWT:** Для генерации и проверки токенов используется библиотека `golang-jwt/jwt`.
- **Хэширование паролей:** Пароли пользователей хэшируются с помощью библиотеки `bcrypt`, что предотвращает хранение паролей в открытом виде.
- **Middleware:** Маршруты, требующие авторизации, защищены с помощью JWT middleware, которая проверяет корректность токена в заголовке запроса.

---

### 3. **Автоматическая генерация документации API**

**Проблема:**  
Ручное обновление документации API требует дополнительных усилий и часто приводит к ошибкам.

**Решение:**  
Использование `swaggo/swag` для генерации документации непосредственно из комментариев в коде. Это позволяет всегда иметь актуальную и удобную для тестирования документацию, доступную по Swagger UI.

---

### 4. **Оптимизация работы с базой данных**

**Проблема:**  
При росте количества пользователей и транзакций необходимо обеспечить высокую производительность и устойчивость работы с базой данных.

**Решение:**

- **Пул соединений:** Настройка пула соединений (параметры `SetMaxOpenConns`, `SetMaxIdleConns` и `SetConnMaxLifetime`) позволила оптимизировать работу с базой данных под высокую нагрузку.

---

## Идеи, нюансы и архитектурные решения

- **Модульная структура:** Разбиение проекта на четко определенные слои (handlers, services, repositories) облегчает масштабирование, тестирование и поддержку.
- **Параллельное выполнение:** При получении информации о пользователе используется пакет `errgroup` для параллельного выполнения независимых запросов (получение инвентаря и транзакций), что снижает общее время ответа.
- **Автоматическая миграция и сидинговые данные:** При запуске проекта происходит автоматическая миграция базы данных и первичное заполнение таблицы мерча, что упрощает начальную настройку.
- **Документирование кода:** В коде присутствуют подробные комментарии к функциям и обработчикам.

---
